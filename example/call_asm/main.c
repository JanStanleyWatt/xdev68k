/*
	アセンブラで直接記述した関数を、C 関数の呼出し規約を利用せず、インライン
	アセンブラから直接コールする方法をまとめます。

	[解説]
		C 関数の呼出し規約は、以下の理由からオーバーヘッドが大きいです。

			1) 引数を常にスタック経由で受け渡ししなければならない
			2) 常にレジスタ d0-d2/a0-a2 が破壊レジスタとして扱われる
			3) 常にメモリバリアが張られる

		インラインアセンブラを利用して直接関数コールすることで、このオーバー
		ヘッドを回避できます。
*/

#include <stdlib.h>
#include <stdio.h>


/*
	strlcpy は、文字列コピーを行う関数である。

		宣言
			size_t strlcpy(char *dst, const char *src, size_t siz);

		引数
			siz = 文字列コピー先のメモリ領域のサイズ
			src = 文字列コピー元
			dst = 文字列コピー先

		戻り値
			コピー先に作成を試みた文字列の長さ（終端 \0 を除く）。
			戻り値 >= siz なら、文字列コピー先のメモり領域が不足
			していたことを示す。

	my_strlcpy は、strlcpy 互換関数のアセンブリコード実装である。
	入力、出力、破壊レジスタは以下のとおりである。

		入力
			d0.l = siz
			a0.l = src
			a1.l = dst

		出力
			d0.l = 戻り値

		破壊
			d0 d1 d2
			a0 a1
*/


#define my_strlcpy(dst, src, siz)											\
	({																		\
		/*																	\
			my_strlcpy は入出力を固定のレジスタで行うので、					\
			この受け渡し用に register 属性をつけた変数が必要。				\
		*/																	\
		register       size_t reg_d0 asm ("d0") = (siz);					\
		register const void * reg_a0 asm ("a0") = (src);					\
		register       void * reg_a1 asm ("a1") = (dst);					\
																			\
		/*																	\
			asm 構文では、入出力レジスタ、破壊レジスタ、メモリバリア		\
			を指定する。													\
																			\
			まず、入出力レジスタと破壊レジスタの指定を行う。				\
			ここでは話を単純にするため、asm 構文の入出力レジスタを、		\
			以下の 3 つのカテゴリに分けて考える。							\
																			\
				1) out														\
					・アセンブラコード内で書き込み専用						\
					・出力リストに記述										\
					・Constranits : "=r"									\
																			\
				2) in out													\
					・アセンブラコード内で読み書き							\
					・出力リストに記述										\
					・Constranits : "+r"									\
																			\
				3) in														\
					・アセンブラコード内で読み取り専用						\
					・入力リストに記述										\
					・Constranits : "r"										\
																			\
			my_strlcpy の d0 a0 a1 は、入力かつ更新または破壊される			\
			レジスタなので、(2) の in out レジスタに分類する。d0 の			\
			出力のみ利用され、a0 a1 は破棄されていると考える。				\
																			\
			破壊リストに記述するレジスタは、入出力レジスタとして			\
			出現せず、破壊だけされるものに限る。my_strlcpy では、			\
			d1 d2 が該当する。												\
																			\
			a0 a1 を破壊レジスタとして破壊リストに記述すると、				\
			Constranits と Clobbers が衝突しているというコンパイル			\
			エラーになる。回避する手段もあるが、顕在化しないバグを			\
			抱えたまま一見動いている状態に陥りやすく、リスクが高い。		\
			上記のとおり a0 a1 は in out レジスタと見なすのが簡単			\
			かつ安全である。												\
																			\
			次に、メモリバリアの指定を行う。								\
			引数 a0.l が指す領域に対し、レジスタ上などにキャッシュ			\
			されたデータを書き戻す必要がある場合は、my_strlcpy 実行			\
			前に書き戻しが完了する必要がある。								\
			また、引数 a1.l が指す領域は my_strlcpy 呼出しによって			\
			書き換えられるので、呼出し前にこの領域からレジスタ等に			\
			キャッシュしたデータは、呼出し後に破棄しなければならない。		\
			このような対処が必要であることをコンパイラに伝えるには、		\
			破壊リストに "memory" を指定してメモリバリアを要求する。		\
																			\
			少し余談になるが、仮に my_strlcpy がユーザーから見える			\
			メモリを read only のみでアクセスし、一切メモリを書き換え		\
			ない動作だとしても、メモリバリアを要求する必要がある。			\
			read only にも関わらず、破壊リストに "memory" を指定する		\
			のは直感に反するかもしれないが、指定を怠ると正常に動作			\
			しないコードが生成されてしまう。								\
		*/																	\
		asm volatile (														\
				"	jbsr	_my_strlcpy\n"									\
		:	/* 出力 */	"+r"	(reg_d0),	/* in out %0 (入力＆戻り値) */	\
						"+r"	(reg_a0),	/* in out %1 (入力＆破壊) */	\
						"+r"	(reg_a1)	/* in out %2 (入力＆破壊) */	\
		:	/* 入力 */														\
		:	/* 破壊 */	"memory",			/* メモリバリアを要求 */		\
						"d1", "d2"											\
		);																	\
		reg_d0;		/* マクロ関数の戻り値（gcc 拡張を利用）*/				\
	})


int main(int argc, char *argv[]){

	char dst[256];
	char src[] = "test string";

	int siz = sizeof(dst);
	int ret = my_strlcpy(dst, src, siz);
	printf(
		"dst = %s\n"
		"siz = %d\n"
		"ret = %d\n"
		"%s",
		dst,
		siz,
		ret,
		(ret >= siz)? "buffer shortage": "succeeded"
	);

	return 0;
}
